name,ring,quadrant,isNew,description
Zero trust architecture (ZTA),Trial,Techniques,TRUE,"<p>The technology landscape of organizations today is increasingly more complex with assets — data, functions, infrastructure and users — spread across security boundaries, such as local hosts, multiple cloud providers and a variety of SaaS vendors. This demands a paradigm shift in enterprise security planning and systems architecture, moving from static and slow-changing security policy management, based on trust zones and network configurations, to dynamic, fine-grained security policy enforcement based on temporal access privileges.</p>
<p><strong>Zero trust architecture (ZTA)</strong> is an organization's strategy and journey to implement zero-trust security principles for all of their assets — such as devices, infrastructure, services, data and users — and includes implementing practices such as securing all access and communications regardless of the network location, enforcing policies as code based on the least privilege and as granular as possible, and continuous monitoring and automated mitigation of threats. Our Radar reflects many of the enabling techniques such as <a href=""/radar/techniques/security-policy-as-code"">security policy as code</a>, <a href=""/radar/techniques/sidecars-for-endpoint-security"">sidecars for endpoint security</a> and <a href=""/radar/techniques/beyondcorp"">BeyondCorp</a>. If you're on your journey toward ZTA, refer to the <a href=""https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207-draft2.pdf"">NIST ZTA publication</a> to learn more about principles, enabling technology components and migration patterns as well as Google's publication on <a href=""https://cloud.google.com/security/beyondprod"">BeyondProd</a>.</p>"
Google BigQuery ML,Assess,Platforms,TRUE,"<p>Often training and predicting outcomes from machine learning models require code to take the data to the model. <strong><a href=""https://cloud.google.com/bigquery-ml/docs"">Google BigQuery ML</a></strong> inverts this by bringing the model to the data. <a href=""https://cloud.google.com/bigquery"">Google BigQuery</a> is a data warehouse designed to serve large-scale queries using SQL, for analytical use cases. Google BigQuery ML extends this function and its SQL interface to create, train and evaluate machine learning models using its data sets; and eventually run model predictions to create new BigQuery data sets. It supports a limited set of models out of the box, such as linear regression for forecasting or binary and multiclass regression for classification. It also supports, with limited functionality, importing previously trained <a href=""/radar/languages-and-frameworks/tensorflow"">TensorFlow</a> models. Although BigQuery ML and its SQL-based approach lower the bar for using machine learning to make predictions and recommendations, particularly for quick explorations, this comes with a difficult trade-off: compromising on other aspects of model training such as <a href=""/radar/techniques/ethical-bias-testing"">ethical bias testing</a>, <a href=""/radar/techniques/explainability-as-a-first-class-model-selection-criterion"">explainability</a> and <a href=""/radar/techniques/continuous-delivery-for-machine-learning-cd4ml"">continuous delivery for machine learning</a>.</p>"
Node overload,Hold,Platforms,TRUE,"<p>Technologies, especially wildly popular ones, have a tendency to be overused. What we're seeing at the moment is <strong>Node overload</strong>, a tendency to use Node.js indiscriminately or for the wrong reasons. Among these, two stand out in our opinion. Firstly, we frequently hear that Node should be used so that all programming can be done in one programming language. Our view remains that <a href=""/radar/techniques/polyglot-programming"">polyglot programming</a> is a better approach, and this still goes <a href=""/radar/languages-and-frameworks/javascript-as-a-first-class-language"">both ways</a>. Secondly, we often hear teams cite performance as a reason to choose Node.js. Although there are myriads of more or less sensible benchmarks, this perception is rooted in history. When Node.js became popular, it was the first major framework to embrace a nonblocking programming model which made it very efficient for IO-heavy tasks. (We mentioned this in our write-up of Node.js in 2012.) Due to its single-threaded nature, Node.js was never a good choice for compute-heavy workloads, though, and now that capable nonblocking frameworks also exist on other platforms — some with elegant, modern APIs — performance is no longer a reason to choose Node.js.</p>"
Dojo,Trial,Tools,TRUE,"<p>A few years ago, Docker — and containers in general — radically changed how we think about packaging, deploying and running our applications. But despite this improvement in production, developers still spend a lot of time setting up development environments and regularly run into ""but it works on my machine"" style problems. <strong><a href=""https://github.com/kudulab/dojo"">Dojo</a></strong> aims to fix this by creating standard development environments, versioned and released as Docker images. Several of our teams use Dojo to streamline developing, testing and building code from local development through production pipelines.</p>"
Jaeger,Trial,Tools,TRUE,"<p><strong><a href=""https://github.com/jaegertracing/jaeger"">Jaeger</a></strong> is an open source distributed tracing system. Similar to <a href=""/radar/tools/zipkin"">Zipkin</a>, it's been inspired by the Google <a href=""https://ai.google/research/pubs/pub36356"">Dapper</a> paper and complies with <a href=""/radar/platforms/opentelemetry"">OpenTelemetry</a>. We've used Jaeger successfully with <a href=""/radar/platforms/istio"">Istio</a> and <a href=""https://www.envoyproxy.io/"">Envoy</a> on Kubernetes and like its <a href=""https://github.com/jaegertracing/jaeger-ui"">UI</a>. Jaeger exposes tracing metrics in the <a href=""/radar/tools/prometheus"">Prometheus</a> format so they can be made available to other tools. However, a new generation of tools such as <a href=""/radar/tools/honeycomb"">Honeycomb</a> integrates traces and metrics into a single observability stream for simpler aggregate analysis. Jaeger joined <a href=""https://www.cncf.io/blog/2017/09/13/cncf-hosts-jaeger/"">CNCF</a> in 2017 and has recently been elevated to CNCF's highest level of maturity, indicating its widespread deployment into production systems.</p>"
Optimal Workshop,Trial,Tools,TRUE,"<p>UX research demands data collection and analysis to make better decisions about the products we need to build. Our teams find <strong><a href=""https://www.optimalworkshop.com"">Optimal Workshop</a></strong> useful because it makes it easy to validate prototypes and configure tests for data collection and thus make better decisions. Features such as first-click, card sorting, or a heatmap of user interaction help to both validate prototypes and improve website navigation and information display. It's an ideal tool for distributed teams since it allows them to conduct remote research.</p>"
Visual regression testing tools,Trial,Tools,TRUE,"<p>Since we first mentioned <strong>visual regression testing tools</strong> in 2014, the use of the technique has spread and the tools landscape has evolved. <a href=""/radar/tools/backstopjs"">BackstopJS</a> remains an excellent choice with new features being added regularly, including support for running inside Docker containers. <a href=""/radar/tools/loki"">Loki</a> was featured in our previous Radar. <a href=""https://applitools.com/"">Applitools</a>, <a href=""https://crossbrowsertesting.com/"">CrossBrowserTesting</a> and <a href=""https://percy.io/"">Percy</a> are SaaS solutions. Another notable mention is <a href=""https://github.com/rsmbl"">Resemble.js</a>, an image diffing library. Although most teams use it indirectly as part of BackstopJS, some of our teams have been using it to analyze and compare images of web pages directly. In general, our experience shows that visual regression tools are less useful in the early stages when the interface goes through significant changes, but they certainly prove their worth as the product matures and the interface stabilizes.</p>"
ConfigCat,Assess,Tools,TRUE,"<p>If you're looking for a service to support dynamic feature toggles (and bear in mind that simple feature toggles work well too), check out <strong><a href=""https://configcat.com/"">ConfigCat</a></strong>. We'd describe it as ""like LaunchDarkly but cheaper and a bit less fancy"" and find that it does most of what we need. ConfigCat supports simple feature toggles, user segmentation, and A/B testing and has a generous free tier for low-volume use cases or those just starting out.</p>"
Snowpack,Assess,Tools,TRUE,"<p><strong><a href=""https://www.snowpack.dev/"">Snowpack</a></strong> is an interesting new entrant in the field of JavaScript build tools. The key improvement over other solutions is that Snowpack makes it possible to build applications with modern frameworks such as <a href=""/radar/languages-and-frameworks/react-js"">React.js</a>, <a href=""/radar/languages-and-frameworks/vue-js"">Vue.js</a>, and <a href=""/radar/languages-and-frameworks/angular"">Angular</a> without the need for a bundler. Cutting out the bundling step dramatically improves the feedback cycle during development because changes become available in the browser almost immediately. For this magic to work, Snowpack transforms the dependencies in <code>node_modules</code> into single JavaScript files in a new <code>web_modules</code> directory, from where they can be imported as an ECMAScript module (ESM). For IE11 and other browsers that don't support ESM, a workaround is available. Unfortunately, because no browser today can import CSS from JavaScript, using CSS modules is <a href=""https://www.snowpack.dev/#importing-css"">not straightforward</a>.</p>"
NestJS,Trial,languages-and-frameworks,TRUE,"<p>The growth in popularity of Node.js and trends such as <a href=""/radar/platforms/node-overload"">Node overload</a> have led to the application of Node.js for developing business applications. We often see problems, such as scalability and maintainability, with large JavaScript-based applications. <strong><a href=""https://nestjs.com/"">NestJS</a></strong> is a <a href=""/radar/languages-and-frameworks/typescript"">TypeScript-first</a> framework that makes the development of Node.js applications safer and less error prone. NestJS is opinionated and comes with SOLID principles and an Angular-inspired architecture out of the box. When building Node.js microservices, NestJS is one of the frameworks that our teams commonly use to empower developers to create testable, scalable, loosely coupled and easily maintainable applications.</p>"
Clinic.js Bubbleprof,Assess,languages-and-frameworks,TRUE,"<p>With the aim of improving performance in our code, profiling tools are very useful to identify bottlenecks or delays in code which are hard to identify, especially in asynchronous operations. <strong><a href=""https://clinicjs.org/bubbleprof/"">Clinic.js Bubbleprof</a></strong> represents visually the async operations in Node.js processes, drawing a map of delays in the application's flow. We like this tool because it helps developers to easily identify and prioritize what to improve in the code.</p>"